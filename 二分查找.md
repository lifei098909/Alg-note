### 二分查找

### 1.介绍
二分查找。也成折半查找(Binary Search)，它是一种效率较高的查找方法，实现原理简单，但细节相对复杂的算法。关于二分查找，有个经典的理解，**思路很简单，细节是魔鬼** 。
二分查找的常用场景一般包括：寻找一个数、寻找左侧边界、寻找右侧边界。而细节，主要体现在，whil循环中用 **<**还是 **<=**，mid是否应该加1等。
下面从常用场景，结合leetcode题目，简单介绍下。

### 2. 寻找一个数
这是最简单的二分查找应用场景，即从有序数组中搜索一个目标数。

**题目描述**

[leetcode 704.二分查找](https://leetcode-cn.com/problems/binary-search/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```cpp
int search(int* nums, int numsSize, int target){
    int left = 0;
    int right = numsSize - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target)
            return mid; // 找到目标值
        else if (nums[mid] < target)
            left = mid + 1;
        else if (nums[mid] > target)
            right = mid - 1;
    }
    return -1;
}
```
现在关于细节问题，做下分析理解：

### 2.1 为什么while循环里要用<=？
我们注意到，在初始化时，**left**值为0，而 **right** 值为 **numsSize - 1**，即最后一个元素的索引为**numsSize - 1**，相当于我们的搜索区间为 **[left, right]**，两端都闭的区间。如果 **right**初值为 **numsSize**时，while循环语句里需要用 **<**作为条件判断。

### 2.2 为什么 **left = mid + 1** 和 **right = mid - 1**？
如上文描述，我们的搜索区间为 **[left, right]**，以mid为中点，逐步缩小查找范围，如果在索引 **mid**里没有找到 **target**，接下来就要搜索 **[left, mid - 1]** 和 **[mid + 1, right]**区间范围内是否有目标值。

### 3.寻找左侧边界

**题目描述**

[153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：

若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]

若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

